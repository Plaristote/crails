#include "<%= filepath[4..filepath.length] %>"

using namespace std;

<%= classname %>::<%= classname %>(MongoDB::Collection& collection, mongo::BSONObj bson_object) : Model(collection, bson_object)
{
}

<%= classname %>::<%= classname %>(const <%= classname %>& copy) : Model(copy)
{
}

SmartPointer<<%= classname %>> <%= classname %>::Find(const string& id_string)
{
  mongo::OID id;

  if (id_str.size() != 24)
    throw MongoDB::Exception(string("Invalid call to <%= classname %>::Find with OID '") + id_str + '\'');
  id.init(id_str);
  {
    SmartPointer<MongoDB::ResultSet<<%= classname %>> > results = MongoDB::ResultSet<<%= classname %>>::Query(QUERY("_id" << id));
    SmartPointer<<%= classname %>>                      result(nullptr);

    if (results->Entries().size() > 0)
      result = new <%= classname %>(results->Entries().front());
    return (result);
  }
}

<%= classname %> <%= classname %>::Create(Data params)
{
  const string         database        = <%= classname %>::DatabaseName();
  const string         collection_name = <%= classname %>::CollectionName();
  MongoDB::Collection& collection      = Databases::singleton::Get()->GetDb<MongodbDb>(database)[collection_name];
  mongo::BSONObj       obj;
  {
    mongo::BSONObjBuilder builder;

    if (!(params.Nil()))
    {
      for_each(params.begin(), params.end(), [&builder](Data param)
      {
        builder << param.Key() << param.Value();
      });
    }
    obj = builder.obj();
  }
  return (<%= classname %>(collection, obj));
}

// FIELDS
void <%= classname %>::initialize_fields()
{
<% fields.each do |field| %>
  <%= field[:name] %>.initialize("<%= field[:name] %>", bson_object, <%= field[:default] %>);
<% end %>
  fields_initialized = true;
}

<% fields.each do |field| %>
<%= field[:type] %> <%= classname %>::get_<%= field[:name] %>(void)
{
  if (fields_initialized == false)
    initialize_fields();
  return <%= field[:name] %>.Get();
}

void <%= classname %>::set_<%= field[:name] %>(<%= field[:type] %> value)
{
  if (fields_initialized == false)
    initialize_fields();
  <%= field[:name] %>.Set(value);
}
<% end %>

// RELATIONS
// belongs_to
<% belongs_to.each do |data| %>
void <%= classname %>::set_<%= data[:relation_name] %>_id(const std::string& id_string)
{
  if (fields_initialized == false)
    initialize_fields();
  set_owner_id("<%= data[:relation_name] %>_id", id_string);
}

<%= data[:type] %> <%= classname %>::<%= data[:relation_name] %>(void)
{
  mongo::OID            foreign_oid = get_<%= data[:relation_name] %>_id();
  mongo::Query          query = QUERY("_id" << foreign_oid);
  MongoDB::Collection&  col   = GetCollection().Db()[<%= data[:type] %>::CollectionName() + 's'];
  auto                  ptr   = col.Query(query);

  if (ptr->more())
  {
    type                  obj(col, ptr->next())

    obj.initialize_fields();
    return (obj);
  }
  return (type(col, mongo::BSONObj()));
}
<% end %>

// has_many
<% has_many.each do |data| %>
MongoDB::ResultSet<<%= data[:type] %>>* <%= classname %>::<%= data[:relation_name] %>s (void)
{
  std::string      association      = <%= data[:type] %>::CollectionName();
  std::string      association_name = string("<%= data[:remote_field] %>") + "_id";
  mongo::Query     query            = QUERY(association_name << OID());
  MongoDB::ResultSet<<%= data[:type] %>>* ptr = MongoDB::ResultSet<<%= data[:type] %>>::Query(collection.Db()[association], query);

  ptr->SetOwner(*this, "<%= data[:relation_name] %>");
  return (ptr);
}
<% end %>

// has_and_belongs_to_many
<% has_and_belongs_to_many.each do |data| %>
MongoDB::ResultSet<<%= data[:type] %>>* <%= classname %>::<%= data[:relation_name] %> (void)
{
  MongoDB::ResultSet<<%= data[:type] %>>* ptr = MongoDB::ResultSet<<%= data[:type] %>>::Query(collection.Db()[<%= data[:type] %>::CollectionName()], BSON("_id" << BSON("$in" << get_<%= data[:relation_name] %>_ids())));
  return (ptr);
}
<% end %>